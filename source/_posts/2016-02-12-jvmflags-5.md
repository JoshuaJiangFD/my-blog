---
layout: post
title: "JVM参数 - Part 5( 新生代垃圾回收 )"
published: true
tags:
	- JVM
categories:
	- Java
---

[Useful JVM Flags – Part 5](https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/)

这部分内容主要关注堆内存的主要几个部分之一，“新生代”。首先笔者会阐述新生代的配置对于Java应用的性能的重要性，然后再介绍与之相关的配置。

从纯粹的功能角度，JVM只需要一块堆空间，不需要区分新生代。引入新生代首要原因是为了提高垃圾回收的性能。具体的说，将堆空间区分成新生代和年老代有两点好处：一是简化了新对象的内存分配（因为新对象只会在新生代分配空间），二是使得对于垃圾对象的回收更高效（通过采用分代回收算法）。

通过对众多面向对象语言的程序的观察发现，大部分的应用都有一个共同的特点：大部分的对象存活期都很短，即创建不久后引用就会被废弃。另外，新创建对象很少会被年老的对象所引用。结合以上两点可以发现，如果能让GC算法快速的遍历所有的新生对象将加快回收的速度 - 如为新创建的对象划分一块专门的区域“新生代”。在这块内存空间里，GC算法能快速的扫描新创建的对象而不需要再遍历年老的对象，

在Sun/Oracle Hotspot JVM的实现中，新生代被继续划分成三个子区域，较大的Eden Space、以及两个较小的Survivor Space,各称为"From"存活区和"To"存活区。规则是，新对象会被首先分配到Eden Space（如果对象过大超过了Eden Space的空闲区域，则直接分配到年老代）。在GC阶段，标记完成后，在Eden Space上的存活对象会被首先复制到Survivor Space中一直到这些对象经历了多次GC仍然存活，会被转移到年老代。所以Survivor Space的作用是使得新生代中的对象再经历第一次GC之后仍会存留在新生代中一段时间，使得它们如果下次GC标记为清除时能迅速回收。

因为我们假设大部分的年轻对象都会很快被GC回收掉，所以生代上的GC一般采用复制策略("Copy Collectin")。在GC开始前，"To"存活区是空的，对象只在"From"存活区和Eden Space中。GC开始时，会标记所有在"From"存活区和Eden Space中需要被回收的对象。对于Eden Space存活的对象会被转移到"To"存活区。From"存活区中依然存活的对象，如果已经达到一定年龄（Tenuring Threshold）则会被转移到年老代，否则依然复制到"To"存活区。在复制阶段结束后，"From"存活区和Eden Space会被清空，所有新生代中依旧存活的对象都被转移到"To"存活区中了。如果在回收过程中，"To"存活区占满，则会立即一次性复制到年老代中。
GC的最后完成时，"From"存活区和"To"存活区会互换角色。所以"To"存活区会为空，为下一次GC做准备，而"From"存活区将包含所有所有存活的对象，新的对象继续在Eden Space上分配。
<!-- more -->
![young_gc.png](/images/young_gc.png)

*例子显示了一次新生代GC的开始和结束状态。空闲空间为绿色。需要清除的对象为黄色，存活饿对象为红色。这个例子中，Survivor Space足够大，因此没有对象被复制到年老代中。*

总结一下，对象总是在Eden Space被创建，在"From"存活区和"To"存活区中保留一段时间，达到一定存活时间后会被转移到年老代中。当对象在年老代中需要被会回收时，就需要更多的工作和更复杂的GC算法了（简单的标记复制算法无法使用，因为已经没有地方可以用来复制了）。

现在可以理解为什么新生代的空间大小很重要：如果新生代过小，则存活期短的对象会被很快拷贝到年老代中，从而更难被回收。相反，如果新生代过大，会有很多对象已经存活很久但是还是在新生代中中来回复制直到被最终复制到年老代。因此我们需要找到一个合适的平衡点。但是找到合适的平衡点这个很难，需要系统性的评估和调试，并且需要借助以下的JVM参数。

**-XX:NewSize 和-XX:MaxNewSize**

之前提过可以通过`-Xms`和`-Xmx`参数设置整个堆空间的大小，同样也有类似的参数`-XX:NewSize`和`-XX:MaxNewSize`设置新生代空间的上下限。不过在用`maxNewSize`设置最大值时要考虑到新生代只是整个堆空间的一部分，会影响到年老代的大小。处于稳定性的考虑，在GC时候可能需要将整个新生代复制到年老代，所以需要限定`-XX:NewSize`的最大值是`-Xmx/2`。

处于性能原因，也可以在启动时设置新生代的初始大小`-XX:NewSize `。如果事先评估过年轻对象的比例，则可以通过设置初始值避免JVM运行时不断调整新生代大小带来的额外开销。

**-XX:NewRatio**

也可以设置新生代和年老代的大小比例，这样带来的的好处是可以自适应JVM不断的调整新生代的大小。例如~-XX:NewRatio=3~可以让年老代的大小始终是新生代的三倍，或者这新生代将占据整个堆内存的1/4，年老代为3/4。

如果我们同时配置新生代的比例和绝对大小，则绝对值会首先考虑，例如下面的例子中，JVM将努力使得新生代的空间是年老代的1/3,但是不超过512MB,而且不低于32MB。

```
$ java -XX:NewSize=32m -XX:MaxNewSize=512m -XX:NewRatio=3 MyApp
```

没有统一的结论表示究竟该使用相对比例还是绝对值设定新生代空间的大小。如果充分了解应用的内存使用情况，不管同时设定堆内存和新生代空间的大小还是只设定相对比例都不错。但是在这方面并没有仔细评估，最正确的方案是让JVM来调整，而不是使用人工参数。如果程序运行稳定就已经皆大欢喜了。即使程序抛出了OOM错误，还是应该首先仔细评估确定根本原因，才能进行人工干预。

**-XX:SurvivorRatio**

`-XX:SurvivorRatio`和`-XX:NewRatio`相似但是是在新生代内部设定Eden Space和Survivor Space的大小比例。例如`-XX:SurvivorRatio=10`表示Eden Space将是"From"存活区和"To"存活区大小的10倍，所以Eden Space将占据整个新生代的10/12, 而"From"存活区和"To"存活区各占据1/12。

调整Survivor Space的大小作用在哪呢？假设Survivor Space大大小远远小于Eden Space，创建新对象分配空间没有问题，这些新对象在下次GC时候都被回收，一切都看起来不错。但是如果有些对象没有回收而Survivor Space的空间不足，那么这些对象在第一次GC时候都会被复制到年老代，这就会带来问题。另一方面如果情况相反：Survivor Space相对较大，那么Eden Space会很快被耗尽，这将会增加新生代GC的频率，同样也会带来问题。

总的来说，我们需要避免将那些存活短的对象过早的转移到年老代，但是同样要避免频繁的触发新生代上的GC。所以这里同样需要找到平衡点，这取决于具体应用的具体特性。一个很好的方法是分析应用中对象的存活时间的分布情况。


**-XX:+PrintTenuringDistribution**

参数`-XX:+PrintTenuringDistribution`可以将JVM在每次新生代GC时打印所有在Survivor Space上的对象的存活年龄分布，存活年龄即对象已经经历过的GC次数。如下是一个输出的实例：

```
Desired survivor size 75497472 bytes, new threshold 15 (max 15)
- age   1:   19321624 bytes,   19321624 total
- age   2:      79376 bytes,   19401000 total
- age   3:    2904256 bytes,   22305256 total
```

第一行表示"To"存活区上共使用了75MB的空间，并且显示了"Tenuring Threshold"的大小为15，即对象在新生代上最多经历15次GC之后就会转移到年老代。这里的输出显示目前阈值为15，最大值也是15。

接下来按存活年龄从小到大显示相应对象的总的字节数，如果某一年龄没有对应的对象则不显示。示例中经历过一次GC的对象为19MB，大约有79KB大小的对象经历过两次GC，大约3MB的对象经历过3次GC。每行的末尾显示按照年龄累加的对象的大小。因此最后一行显示目前"To"存活区内年龄从1到3累加的对象大小为22MB。因为当前目标阈值为75MB，而且"Tenuring Threshold"的大小为15，所以本次GC不需要转移对象到年老代中。假设下一次GC打印出以下信息：

```
Desired survivor size 75497472 bytes, new threshold 2 (max 15)
- age   1:   68407384 bytes,   68407384 total
- age   2:   12494576 bytes,   80901960 total
- age   3:      79376 bytes,   80981336 total
- age   4:    2904256 bytes,   83885592 total
```

通过比较可以发现上次存活年龄为2和3的对象都没有被回收，并且分别递增为3和4。本次GC回收一部分对象，因为年龄为2的字节数减少了。另外本次GC从Eden Space张新增的68MB对象被拷贝到"To"存活区了。

注意到本次GC之后，"To"存活区总共使用了83MB的空间，已经超过了75MB的阈值，因此JVM将"Tenuring Threshold"的阈值调整为2，这意味着在下一次GC时，将有一部分年龄超过2的对象要么被回收（已经不再被引用）要么被转移到年老代中。

**-XX:InitialTenuringThreshold, -XX:MaxTenuringThreshold 和 -XX:TargetSurvivorRatio**

`-XX:InitialTenuringThreshold`和`-XX:MaxTenuringThreshold`参数可以调整"Tenuring Threshold"的初始值和最大值。`-XX:TargetSurvivorRatio`可以用来设置"To"存活区在每次GC之后的目标占用比。综合两个参数`-XX:MaxTenuringThreshold=10`和`-XX:TargetSurvivorRatio=90`限定了"Tenuring Threshold"的上限为10并且"To"存活区每次GC的目标占用比为50%。

虽然有这些参数可以用来调试年轻代，但是没有一个统一的准则来指导如何调试。以下两点思路稍微清晰一点：

-  如果存活时间分布有大量的对象年龄一直递增直到超过"Tenuring Threshold"才被回收，说明也许应该降低`-XX:MaxTenuringThreshold`的值；
-  如果`-XX:MaxTenuringThreshold`值大于1，而且大部分的对象存活年龄从未超过1，那么我们需要检查一下存活区的空间利用比阈值是否达到了参数`-XX:TargetSurvivorRatio`设定的值。如果从未目标占用比阈值，超过说明所有的年轻对象都很快很回收了，这是理想情况。但是如果标占用比阈值被频繁触发，说明JVM将有部分存活年龄为1的对象拷贝到了年老代，这种情况下我们需要调整存活区的大小或者提高存活区目标占用比。

**-XX:+NeverTenure 和 -XX:+AlwaysTenure**

最后,我们介绍2个颇为少见的参数,对应2种极端的新生代GC情况。设置参数`-XX:+NeverTenure`会使得对象永远不会转移到老年代.除非我们确定不需要老年代时，否则这样设置风险很大,并且会浪费至少一半的堆内存。相反设置参数`-XX:+AlwaysTenure`表示没有存活区,所有对象在第一次GC时，会直接转移到老年代。
在生产环境下并没有合理的场景使用这个参数，除非在测试环境中，看下这样设置会发生什么有趣的事。除此之外并不推荐使用这些参数。

**结论**

新生代的配置对程序还是很重要的，这里介绍了一些相应的参数。但是如果仅仅配置新生代而不考虑年老代也不行。在配置堆内存或者GC算法时，需要兼顾虑两者之间的相互影响。
