---
layout: post
title: "JVM参数 - Part 8( GC日志 )"
published: true
tags:
	- JVM
categories:
	- Java
---

[Useful JVM Flags – Part 8](https://blog.codecentric.de/en/2014/01/useful-jvm-flags-part-8-gc-logging/)

这个系列博客的最后一部分将会介绍JVM的GC日志和相关的参数。GC日志对于优化堆设置、GC参数或者分析应用分配对象的特征都至关重要。GC日志详细记录了每次GC的过程和结果的准确数据。
<!-- more -->
**-XX:PrintGC**

`-XX:PrintGC`（或者`-verbose:gc`）会让JVM将GC的简单信息打印出来，包括新生代GC和Full GC。下面是一个例子：
```
[GC 246656K->243120K(376320K), 0,0929090 secs]
[Full GC 243120K->241951K(629760K), 1,5589690 secs]
```
每一行开始是GC的类型，后面是堆上GC前后的占用情况，括号内是当前堆的总大小，最后是每次GC的用时。例如第一行的日志标识GC使得堆上的对象从246656K降低到243120K，当前总大小为376320K，总耗时为0.093s。
简单的GC日志没有体现具体的GC算法差异，例如多少对象从新生代转移到了年老代。所以需要更详细的GC日志。

**-XX:+PrintGCDetails**

`-XX:+PrintGCDetails`参数会打印更详细的日志，下面是一个吞吐量优先的回收器上一次GC的日志输出，这里为了更可读，加了一些分行和缩进，实际输出只是一行。

```
[GC
    [PSYoungGen: 142816K->10752K(142848K)] 246648K->243136K(375296K),
    0,0935090 secs
]
[Times: user=0,55 sys=0,10, real=0,09 secs]
```

从输出可以看出，一次新生代上的GC将堆上已用空间从246648K降低到243136K，耗时0.0.935秒。另外可以看出新生代上大小为142848K，使用的回收器为`PSYoungGen`。另外从新生代GC的结果来看触发GC的原因是因为已经没有足够的内存给新创建的对象。另外通过对比发现，虽然新生代上可用空间增大（142816K->10752K），但是总体堆内从占用没有减少（246648K->243136K），有大量的对象从新生代拷贝到了年老代。

`Times`行显示了GC占用的CPU时间，分为用户态(User)和核心态（Sys）。另外实际运行时间为0.0.9秒。这里用户态的时间远远大于实际运行时间，可见GC是多线程运行的。CPU时间统计的是所有核上的时间之和。相除可以得知，大概有8个线程并发执行GC。

下面是一个Full GC的输出：

```
[Full GC
    [PSYoungGen: 10752K->9707K(142848K)]
    [ParOldGen: 232384K->232244K(485888K)] 243136K->241951K(628736K)
    [PSPermGen: 3162K->3161K(21504K)],
    1,5265450 secs
]
[Times: user=10,96 sys=0,06, real=1,53 secs]
```
Full GC打印出了年老代和永久代的GC信息。从日志可以看到三个内存区域使用的不同GC算法以及GC时的空间大小。例子中628736K为堆空间的总容量，142848K属于新生代，485888K属于年老代。Full GC耗时1.53秒，占用CPU时间为10.96秒（用户态），可见GC是并发执行的。（同上使用了8个线程）

详细日志可以让我们推理是哪一块内存区域触发了GC。如果某一块区域在GC发生时的占用空间几乎等于总空间，则可以判断是这块区域触发了GC。但是在上面这个例子中三个区域都没有快占满，那么是什么原因呢？
在使用吞吐量优先的回收器时，如果JVM可以在需要的时候主动触发一次GC，而不需要等待某一块区域空间被耗尽。

应用可以调用JDK API主动请求Sysmtem GC，这时在GC日志中会打印"Full GC(System)"开头，而不是"Full GC"。

串行回收器的详细日志和吞吐量优先的回收器相似，除了日志开头打印的具体GC方法名不同，例如串行GC称年老代为"Tenured"而不是"ParOldGen"。使用具体GC方法名有一个好处，是让我们从日志直接了解JVM设置的具体细节。

使用CMS回收器时，新生代上的回收日志和吞吐量优先的回收器大致相同。但是在年老代上有所不同，CMS回收器在年老代上的GC过程大部分和应用会并发进行，打印的日志并不连续，可能会混杂新生代的GC日志中间。但是如果理解了日志的输出方式，理解起来并不困难。唯一需要注意的是，CMS回收的日志时间跨度可能比较大，这是正常的。

另外前面提到过，如果CMS回收器没能及时回收空间，JVM还是可能会触发Full GC。这种情况下Full GC的日志会打印出原因，即前面提到过的“并发模式故障”("Concurrent Mode Failure")。

由于篇幅所限，这里不再展开解释CMS回收器的详细日志，但是强烈推荐这个算法的作者的[一篇文章](https://blogs.oracle.com/jonthecollector/entry/the_unspoken_cms_and_printgcdetails)。

**-XX:+PrintGCTimeStamps 和 -XX:+PrintGCDateStamps**

可以为GC日志添加具体时间戳，`-XX:+PrintGCTimeStamps`为每次GC打印相对从JVM启动以来的时间增量。例如：

```
0,185: [GC 66048K->53077K(251392K), 0,0977580 secs]
0,323: [GC 119125K->114661K(317440K), 0,1448850 secs]
0,603: [GC 246757K->243133K(375296K), 0,2860800 secs]
```

`-XX:+PrintGCDateStamps`打印绝对值时间，例如：

```
2014-01-03T12:08:38.102-0100: [GC 66048K->53077K(251392K), 0,0959470 secs]
2014-01-03T12:08:38.239-0100: [GC 119125K->114661K(317440K), 0,1421720 secs]
2014-01-03T12:08:38.513-0100: [GC 246757K->243133K(375296K), 0,2761000 secs]
```

推荐同时设置这两个参数`-XX:+PrintGCTimeStamps` 和 `-XX:+PrintGCDateStamps`，这样在分析的时候可以通过时间戳方便的关联其他信息。

**-Xloggc**

GC日志默认输出到标准输出，可以通过设置`-Xloggc:<file>`将日志打印到单独的文件。注意使用这个参数将隐式的启用`-XX:+PrintGC`参数和`-XX:+PrintGCTimeStamps`参数。但是为了防止以后的JVM做出调整，还是建议显式的加上这两个参数。

**“Manageable” Flags**

关于打印GC日志是否会带来额外开销这个问题经常被讨论。其实这个开销很小，因此笔者强烈建议加上这个参数。另外，其实不一定要在JVM启动前设置好这个参数，可以在运行时管理参数。

Hotspot JVM 有一小类参数成为"Manageable Flags", 这些参数可以在运行时设置。所以这里讨论的参数，以及以"PrintGC"开头的参数都属于这一类。使用这一功能需要借助于JDK自带的`jinfo`工具，或者使用JMX客户端，调用名为`"HotSpotDiagnostic"`的MBean对象上的`"setVMOption"`方法。










