---
layout: post
title: "JVM参数 - Part 6( Parallel GC回收器 )"
published: true
tags:
	- JVM
categories:
	- Java
---

[Useful JVM Flags – Part 6](https://blog.codecentric.de/en/2013/01/useful-jvm-flags-part-6-throughput-collector/)

对于大部分的Java应用，在实践中我们发现对于GC算法的评价一般根据两个标准：
1. 吞吐量越高，算法越好
2. 暂停时间越短，算法越好

首先让我们来明确垃圾收集(GC)中的两个术语:吞吐量(throughput)和暂停时间(pause times)。 JVM总是在专门的GC线程(GC threads)中执行垃圾回收。只要GC线程是活动的，它们将与应用程序线程(application threads)争用当前可用CPU的时钟周期。我们把吞吐量简单的定义为应用程序线程用时占程序总用时的比例。 例如，吞吐量99/100意味着每100秒的程序执行时间内，应用程序线程运行了99秒，而GC线程运行了1秒。

术语”暂停时间”是指垃圾回收过程中应用程序线程完全暂停等待GC线程执行的时间。例如100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。“平均暂停时间”100毫秒是指该应用程序所有GC的暂停时间平均为100毫秒。同样“最大暂停时间”100毫秒是指该应用程序所有的暂停时间最大不超过100毫秒。
<!-- more -->
**吞吐量和暂停时间**

因为用户只关心程序的实际工作时间，所以吞吐量越高用于越满意。吞吐量越高，用户的直观感受是程序运行越快，响应越及时。暂停时间同样影响用户体验，因为用户会感觉程序卡死或者短暂的无法响应，但并关心到到底是程序问题还是垃圾回收之类的底层原因。正常情况下超过200毫秒的暂停时间就会相当破坏用户体验了，因此对于交互类的应用，降低最大暂停时间非常必要。

不幸的是，吞吐量和暂停时间是相互竞争的。可以简化下问题然后这样假设：正确运行垃圾回收需要一定的前提条件，比如当GC线程在标记清除对象时应用线程不可以修改对象的状态，所以在GC回收时应用线程必须暂停（具体GC算法有不同的暂停阶段）。这些会带来线程调度的额外开销：直接开销如上下文切换以及间接的比如缓存清空。加上其他JVM的GC需要的安全机制，这意味着每次GC除了GC线程执行实际工作的时间之外，都会有一些不可避免的额外负载。所以为了提高吞吐量我们需要尽量降低GC的频率，这样均摊到每次GC上的开销就会降低。

但是仅仅降低GC的频率意味着每次GC的任务量加大了，因此每次GC时候堆空间聚集起来需要处理的对象更多。单次GC执行的时间延长，这反过来会增加“平均暂停时间”和“最大暂停时间”。所以如果考虑暂停时间，就需要增加GC频率，这样每次GC可以执行的更快，这反过来又会增加工作量并降低吞吐量指标。

总结一下，当设计（或者使用）GC算法时候，我们需要想好目标是什么：一个GC算法只能同时满足一个目标（最大吞吐量或者最低暂停时间），或者寻找一个平衡点。

**HotSpot JVM的垃圾回收**

第五部分已经讲到了新生代上的垃圾回收。对于年老代上的回收，Hotspot JVM提供了两类算法（不包括新的G1 回收算法）。第一类是吞吐量优先第二类是暂停时间优先。下面集中讲述吞吐量优先的算法。

因为我们还是围绕JVM参数来展开，所以只会大致介绍一下Hotspot的吞吐量优先的GC算法。如果年老代空间不足分配会触发GC（一般是年轻代拷贝或者直接分配导致的）。GC回收器从GC Root出发并标记堆中所有存活的对象，然后在年老代中移动这些存活的对象到一块完整的内存空间中，并将剩余的空间标记为可用。年老代中的回收并没有新生代中复制的过程，而是在同一块内存区域内执行碎片整理程序。回收器使用多个线程来执行回收，多个GC线程会先划分好各自的区域后工作，互不干扰。在GC期间，所有的应用线程都是暂停的。下面是一些相关的参数了。

**-XX:+UseSerialGC**

这个参数使得JVM使用串行GC，即单个GC线程来回收新生代和年老代。对于单核机器上的应用推荐此设置，因为多个GC线程在单核机器上只会增加线程调度的开销。

**-XX:+UseParallelGC**

这个参数使得JVM使用并行回收，即多个GC线程执行新生代上的回收。在Java 6上笔者不推荐使用该参数。因为`-XX:+UseParallelOldGC`更适合。但是在Java 7上情况不同(见此文)，`-XX:+UseParallelGC`和`-XX:+UseParallelOldGC`效果已经一样了。

**-XX:+UseParallelOldGC**

这个参数中的old并不表示是被废弃的参数，而是指年老代。`-XX:+UseParallelOldGC`更适合在多核机器上，因为它同时对新生代和年老代执行并行回收。笔者建议在多核机器上，对于吞吐量优先的场景采用该配置。

**-XX:ParallelGCThreads**

`-XX:ParallelGCThreads=<value>`可以用来设置GC线程的数目，例如`-XX:ParallelGCThreads=6`表示每次GC将启动6个GC线程。默认情况下JVM会根据机器的处理器数目（物理核或者虚拟核），可以通过JDK中的`Runtime.avaiableProcessors()`来决定。对于n<=8的情况，JVM将会启动相同数目的GC线程，对于n>8的情况，将启动`3+5N/8`个线程。

如果机器上只有单个应用在执行，那么使用JVM的默认配置是合理的。但是如果同一台机器有其他JVM在执行或者其他CPU密集型的进程，需要使用`-XX:ParallelGCThreads`参数设置成合理的值。例如一台16核的服务器上有四个JVM进程，那么`-XX:ParallelGCThreads=4`比较合理，因为不同JVM进程的GC线程不会相互干扰。

**-XX:-UseAdaptiveSizePolicy**

吞吐量优先的GC算法都引入了一个有趣的机制来改善GC配置的友好性。这个机制是"JVM工效学"的一部分，在Java5被引入。这种机制会让JVM在运行时动态的调整堆空间的大小以及回收设置，如果JVM认为这些调整可以提高GC的性能。具体性能的提高可以参考这两个参数`-XX:GCTimeRatio`和`-XX:MaxGCpauseMills`（见下面）。

这一机制是默认生效的，因为JVM的确应该具备自适应调整配置的特点。但是如果对于特定应用需要什么样的配置用户很清楚，那么可以通过`-XX:-UseAdaptiveSizePolicy`参数阻止JVM在运行时动态调整配置。

**-XX:GCTimeRatio**

`-XX:GCTimeRatio=<value>`用来告诉JVM期望的吞吐量，`-XX:GCTimeRatio=9`表示期望应用线程的执行时间至少占到整个程序执行之间的9/10，那么在运行时JVM会试图动态修改堆空间和GC的配置来达到这一目标。默认的
`-XX:GCTimeRatio`为99，即应用线程的执行时间要占到总用时的99%。

**-XX:MaxGCPauseMillis**

`-XX:GCTimeRatio=<value>`用来告诉JVM期望的最大的暂停时间。在运行时回收器会基于其观察到的GC暂停时间计算加权均值和标准方差。如果统计值超过了期望值，JVM会尝试修改修改堆空间和GC的配置来达到这一期望值。记住对于新生代和年老代的最大暂停时间是分开计算的，另外默认JVM没有配置这一指标。

如果同时这是了最小吞吐量和最大暂停时间，最大暂停时间优先级更高。另外JVM不保证能达到任一设定的目标，这都取决于具体的应用。

当设置最大暂停时间时应该避免设置的值过小。因为前面提及了为了降低最大暂停时间，JVM会启动更多的GC线程，这会显著的影响吞吐量。特别对于大部分的Web应用来说，更关心最大暂停时间，所以这里不推荐使用吞吐量优先的回收器，而是切换到CMS回收器。这是下一章的重点内容。
